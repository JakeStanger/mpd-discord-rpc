Index: src/album_art.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::mpd_conn::try_get_first_tag;\nuse mpd_client::commands::responses::Song;\nuse mpd_client::Tag;\nuse reqwest::blocking::Client;\nuse serde::Deserialize;\nuse std::collections::HashMap;\n\n#[derive(Deserialize)]\nstruct SearchResult {\n    releases: Vec<Release>,\n}\n\n#[derive(Deserialize)]\nstruct Release {\n    id: String,\n}\n\npub struct AlbumArtClient {\n    release_cache: HashMap<(String, String), String>,\n}\n\nimpl AlbumArtClient {\n    pub fn new() -> AlbumArtClient {\n        let release_cache = HashMap::new();\n        AlbumArtClient { release_cache }\n    }\n\n    /// Searches for a release on MusicBrainz\n    /// Returns its ID if one is found.\n    fn find_release(&mut self, artist: String, album: String) -> Option<String> {\n        static APP_USER_AGENT: &str =\n            concat!(env!(\"CARGO_PKG_NAME\"), \"/\", env!(\"CARGO_PKG_VERSION\"));\n\n        let query = format!(\"artist:{} AND release:{}\", &artist, &album);\n\n        let cache_key = (artist, album);\n        if self.release_cache.contains_key(&cache_key) {\n            return Some(self.release_cache.get(&cache_key).unwrap().to_string());\n        }\n\n        let url = format!(\n            \"https://musicbrainz.org/ws/2/release/?query={}&limit=1\",\n            query\n        );\n\n        let client = Client::builder()\n            .user_agent(APP_USER_AGENT)\n            .build()\n            .expect(\"Failed to create HTTP client\");\n\n        let response = client.get(&url).header(\"Accept\", \"application/json\").send();\n\n        if let Ok(response) = response {\n            if response.status() != 200 {\n                return None;\n            }\n\n            let response = response\n                .json::<SearchResult>()\n                .expect(\"Received response from MusicBrainz in unexpected format\");\n\n            let id = response.releases.first().map(|release| release.id.clone());\n\n            match id {\n                Some(id) => {\n                    self.release_cache.insert(cache_key, id.clone());\n                    Some(id)\n                }\n                None => None,\n            }\n        } else {\n            None\n        }\n    }\n\n    /// Attempts to get the URL to the current album's front cover\n    /// by fetching it from MusicBrainz.\n    ///\n    /// Uses MPD's internal MusicBrainz album ID tag if its set,\n    /// otherwise falls back to searching.\n    pub fn get_album_art_url(&mut self, song: Song) -> Option<String> {\n        let mb_album_id = match try_get_first_tag(song.tags.get(&Tag::MusicBrainzReleaseId)) {\n            Some(id) => Some(id.to_string()),\n            None => {\n                let tags = song.tags;\n                let artist = try_get_first_tag(tags.get(&Tag::Artist));\n                let album = try_get_first_tag(tags.get(&Tag::Album));\n\n                match (artist, album) {\n                    (Some(artist), Some(album)) => {\n                        self.find_release(artist.to_string(), album.to_string())\n                    }\n                    _ => None,\n                }\n            }\n        };\n\n        mb_album_id.map(|id| format!(\"https://coverartarchive.org/release/{}/front\", id))\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/album_art.rs b/src/album_art.rs
--- a/src/album_art.rs	(revision 498a2d92a70377c0a66cdcdc788df01a531dd911)
+++ b/src/album_art.rs	(date 1655654831787)
@@ -95,6 +95,6 @@
             }
         };
 
-        mb_album_id.map(|id| format!("https://coverartarchive.org/release/{}/front", id))
+        mb_album_id.map(|id| format!("https://coverartarchive.org/release/{}/front-250", id))
     }
 }
